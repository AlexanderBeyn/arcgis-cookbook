require "net/http"
require "uri"
require "json"

module ArcGIS
  class ServerAdminClient

    @server_url = nil
    @admin_username = nil
    @admin_password = nil
    
    def initialize(server_url, admin_username, admin_password)
      @server_url = server_url
      @admin_username = admin_username 
      @admin_password = admin_password
    end
    
    def wait_until_available()
      Utils.wait_until_url_available(@server_url + "/")
    end
    
    def site_exist?()
      uri = URI.parse(@server_url + "/admin/?f=json")

      request = Net::HTTP::Get.new(uri.request_uri)
      
      http = Net::HTTP.new(uri.host, uri.port)
      http.read_timeout = 3600
  
      if uri.scheme == "https"
        http.use_ssl = true
        http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      end

      response = http.request(request)
      
      if response.code.to_i == 200
        error_info = JSON.parse(response.body)
        if error_info['code'].to_i == 499
          return true
        end
      end
      
      return false
    end
    
    def create_site(server_directories_root)
      wait_until_available()
      
      config_store_connection = {
        "type" => "FILESYSTEM",
        "connectionString" => ::File.join(server_directories_root, "config-store")
      }
  
      directories = {"directories" => [
        {
        "name" => "arcgiscache",
        "physicalPath" => ::File.join(server_directories_root, "directories", "arcgiscache"),
        "directoryType" => "CACHE",
        "cleanupMode" => "NONE",
        "maxFileAge" => 0,
        "description" => "Stores tile caches used by map, globe, and image services for rapid performance.",
        },
        {
        "name" => "arcgisjobs",
        "physicalPath" => ::File.join(server_directories_root, "directories", "arcgisjobs"),
        "directoryType" => "JOBS",
        "cleanupMode" => "TIME_ELAPSED_SINCE_LAST_MODIFIED",
        "maxFileAge" => 360,
        "description" => "Stores results and other information from geoprocessing services.",
        },
        {
        "name" => "arcgisoutput",
        "physicalPath" => ::File.join(server_directories_root, "directories", "arcgisoutput"),
        "directoryType" => "OUTPUT",
        "cleanupMode" => "TIME_ELAPSED_SINCE_LAST_MODIFIED",
        "maxFileAge" => 10,
        "description" => "Stores various information generated by services, such as map images.",
        },
        {
        "name" => "arcgissystem",
        "physicalPath" => ::File.join(server_directories_root, "arcgissystem"),
        "directoryType" => "SYSTEM",
        "cleanupMode" => "NONE",
        "maxFileAge" => 0,
        "description" => "Stores directories and files used internally by ArcGIS Server.",
        }]
      }
  
      log_settings = {
        "logLevel" => "INFO",
        "logDir" => ::File.join(server_directories_root, "logs"),
        "maxErrorReportsCount" => 10,
        "maxLogFileAge" => 90
      }

      request = Net::HTTP::Post.new(URI.parse(@server_url + '/admin/createNewSite').request_uri)
  
      request.set_form_data({
        "username" => @admin_username,
        "password" => @admin_password,
        "configStoreConnection" => config_store_connection.to_json,
        "directories" => directories.to_json,
        "settings" => log_settings.to_json,
        "cluster" => "",
        "f" => "json"})
  
      response = send_request(request)
  
      validate_response(response)
    end
    
    def enable_ssl()
      request = Net::HTTP::Post.new(URI.parse(@server_url + "/admin/security/config/update").request_uri)
      request.add_field("Referer", "referer")
    
      token = generate_token(@server_url + "/admin/generateToken")
    
      request.set_form_data({
        "Protocol" => "HTTP_AND_HTTPS",
        "authenticationTier" => "GIS_SERVER",
        "allowDirectAccess" => "on",
        "virtualDirsSecurityEnabled" => "on",
        "allowedAdminAccessIPs" => "",
        "token" => token,
        "f" => "json"})
    
      response = send_request(request)
    
      validate_response(response)
    end
    
    def register_database(data_item_path, connection_string, is_managed)
      if !(connection_string.nil? || connection_string.empty?)
        request = Net::HTTP::Post.new(URI.parse(@server_url + "/admin/data/registerItem").request_uri)
        request.add_field("Referer", "referer")
      
        token = generate_token(@server_url + "/admin/generateToken")
      
        item = {
          "path" => data_item_path,
          "type" => "egdb",
          "clientPath" => nil,
          "info" => {
          "isManaged" => is_managed,
          "dataStoreConnectionType" => "serverOnly",       
          "connectionString" => connection_string
          }
        }
      
        request.set_form_data({
          "item" => item.to_json,
          "token" => token,
          "f" => "json"})
      
        response = send_request(request)
      
        validate_response(response)
      end
    end
    
    def federate(portal_url, portal_token, server_id, secret_key)
      request = Net::HTTP::Post.new(URI.parse(@server_url + "/admin/security/config/update").request_uri)
      request.add_field("Referer", "referer")
      
      token = generate_token(@server_url + "/admin/generateToken")
    
      security_config = {
        "securityEnabled" => true,
        "authenticationMode" => "ARCGIS_PORTAL_TOKEN",
        "authenticationTier" => "ARCGIS_PORTAL",
        "userStoreConfig" => {
          "type" => "PORTAL",
        },
        "sslEnabled" => true,
        "httpEnabled" => true,
        "virtualDirsSecurityEnabled" => true,
        "portalProperties" => {
          "portalUrl" => portal_url,
          "privatePortalUrl" => portal_url,
          "portalSecretKey" => secret_key,
          "portalMode" => "ARCGIS_PORTAL_FEDERATION",
          "serverId" => server_id,
          "serverUrl" => @server_url,
          "token" => portal_token,
          "referer" => "referer"
        },
        "allowDirectAccess" => true
      }
    
      request.set_form_data({
          "token" => token,
          "securityConfig" => security_config.to_json,
          "f" => "json"})
    
      response = send_request(request)
    
      validate_response(response)
    
      sleep(180.0)
      
      #Federate services
      wait_until_available()
      
      request = Net::HTTP::Post.new(@server_url + "/admin/services/federate")
      request.add_field("Referer", "referer")
      request.set_form_data({
          "token" => portal_token,
          "f" => "json"})
    
      response = send_request(request)
  
      validate_response(response)
    end

    def generate_token(generate_token_url)
      request = Net::HTTP::Post.new(URI.parse(generate_token_url).request_uri)
  
      request.set_form_data({
          "username" => @admin_username,
          "password" => @admin_password,
          "client" => "referer",
          "referer" => "referer",
          "expiration" => "600",
          "f" => "json"})
  
      response = send_request(request)
      
      validate_response(response)
      
      token = JSON.parse(response.body)
  
      return token['token']
    end

    private
     
    def send_request(request) 
      uri = URI.parse(@server_url);
    
      http = Net::HTTP.new(uri.host, uri.port)
      http.read_timeout = 3600
  
      if uri.scheme == "https"
        http.use_ssl = true
        http.verify_mode = OpenSSL::SSL::VERIFY_NONE
      end

      Chef::Log.debug("Request: #{request.method} #{uri.scheme}://#{uri.host}:#{uri.port}#{request.path}")
      
      if !request.body.nil?
        Chef::Log.debug(request.body)
      end
      
      response = http.request(request)
      
      if response.code.to_i == 301
        Chef::Log.debug("Moved to: #{response.header['location']}")
        
        uri = URI.parse(response.header['location']);

        http = Net::HTTP.new(uri.host, uri.port)
        http.read_timeout = 3600
    
        if uri.scheme == "https"
          http.use_ssl = true
          http.verify_mode = OpenSSL::SSL::VERIFY_NONE
        end

        if request.method == "POST"
          body = request.body 
          request = Net::HTTP::Post.new(URI.parse(response.header['location']).request_uri)
          request.body=(body)
        else
          request = Net::HTTP::Get.new(URI.parse(response.header['location']).request_uri)
        end

        request.add_field("Referer", "referer")
                
        response = http.request(request)
      end
      
      Chef::Log.debug("Response: #{response.code} #{response.body}")

      return response
    end
    
    def validate_response(response)
      if response.code.to_i == 301
        raise "Moved permanently to " + response.header['location']
      elsif response.code.to_i > 300 
        raise response.message
      else 
        if response.code.to_i == 200
          error_info = JSON.parse(response.body)
          if error_info['status'] == "error"
            raise error_info['messages'].join(" ")
          end
        end
      end
    end
  end
end